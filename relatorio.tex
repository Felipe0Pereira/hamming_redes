\UseRawInputEncoding
\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{multicol}

\geometry{margin=2cm}

% Configuração para código C
\lstset{
    language=C,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray}
}

\title{
    \includegraphics[scale=0.6]{logoUFPR.png} \\
    \vspace*{0.5cm}
    {\huge\bfseries Relatório} \\
    \vspace*{0.5cm}
    {\Large Implementação do Código de Hamming} \\
    \vspace*{0.5cm}
    {\normalsize Algoritmo de Correção de Erros} \\
    \vspace*{3cm}
}
\author{Pedro Henrique Marques de Lima \\ Felipe Gonçalves Pereira}
\date{9 de Junho de 2025}

\begin{document}

\maketitle

\newpage
\tableofcontents
\newpage

\section{Introdução}

O código de Hamming é um algoritmo de correção de erros desenvolvido por Richard Hamming em 1950. Este relatório apresenta uma implementação em C que utiliza códigos de Hamming (31,26) para codificar e decodificar arquivos, permitindo a detecção e correção de erros em um único bit.

A implementação analisada processa blocos de 26 bits de dados, adicionando 5 bits de paridade para formar palavras-código de 31 bits, proporcionando capacidade de correção de erro único.

\section{Fundamentos Teóricos}

\subsection{Código de Hamming (31,26)}
O código implementado utiliza:
\begin{itemize}
    \item \textbf{Bits de dados}: 26 bits
    \item \textbf{Bits de paridade}: 5 bits
    \item \textbf{Comprimento total}: 31 bits
\end{itemize}

Os bits de paridade são posicionados nas posições que são potências de 2: $2^0, 2^1, 2^2, 2^3, 2^4$ (posições 1, 2, 4, 8, 16).

\subsection{Detecção e Correção}
O algoritmo utiliza operação XOR para:
\begin{itemize}
    \item Calcular bits de paridade durante codificação
    \item Localizar posição do erro durante decodificação
    \item Corrigir automaticamente erros únicos
\end{itemize}

\section{Implementação}

\subsection{Estrutura Principal}
O programa oferece duas operações principais:
\begin{itemize}
    \item \textbf{Codificação}: Converte arquivo original em arquivo com código de Hamming
    \item \textbf{Decodificação}: Recupera arquivo original com correção de erros
\end{itemize}

\subsection{Função de Codificação}
A função \texttt{encripta()} implementa o algoritmo de codificação:

\begin{lstlisting}[basicstyle=\tiny\ttfamily]
uint32_t encripta (uint32_t block) {
    unsigned int codded = 0;
    unsigned int xor = 0;
    
    // Posiciona bits de dados
    for (int i = 0, pot = 1, j = 0; i < 31; i++) {
        if ((i+1) == pot) {
            pot *= 2;
        } else {
            unsigned int bit = (block >> j) & 1;
            codded |= (bit << i);
            if (bit) xor ^= (i+1);
            j++;
        }
    }
    
    // Adiciona bits de paridade
    for (int pot = 1, i = 0; i < 5; pot *= 2, i++) {
        codded |= (((xor >> i) & 1) << (pot - 1));
    }
    return codded;
}
\end{lstlisting}

\subsection{Função de Decodificação}
A função \texttt{decodifica()} implementa detecção e correção:

\begin{lstlisting}[basicstyle=\tiny\ttfamily]
int32_t decodifica (unsigned long int block) {
    unsigned long int xor = 0;
    
    for (int i = 0; i < 31; i++) {
        if ((block >> i) & 1)
            xor ^= (i+1);
    }
    
    if (xor) 
        block ^= 1 << (xor-1);
    
}
\end{lstlisting}

\section{Processamento de Arquivos}

\subsection{Codificação de Arquivos}
O processo de codificação segue os passos:

\begin{enumerate}
    \item Armazena tamanho original do arquivo
    \item Lê arquivo em blocos de 104 bytes
    \item Divide cada bloco em chunks de 26 bits
    \item Aplica código de Hamming em cada chunk
    \item Escreve resultado em formato texto binário
\end{enumerate}

\subsection{Decodificação de Arquivos}
A decodificação realiza:

\begin{enumerate}
    \item Recupera tamanho original do arquivo
    \item Lê linhas do arquivo codificado
    \item Aplica decodificação com correção de erros
    \item Reconstrói arquivo original byte a byte
    \item Garante tamanho exato do arquivo original
\end{enumerate}

\section{Características da Implementação}

\subsection{Gerenciamento de Bits}
A implementação utiliza técnicas eficientes de manipulação de bits:

\begin{itemize}
    \item Operações de deslocamento (\texttt{<<}, \texttt{>>})
    \item Máscaras de bits (\texttt{\&}, \texttt{|}, \texttt{\^{}})
    \item Buffer de 64 bits para acumulação
\end{itemize}

\subsection{Formato de Arquivo}
Os arquivos codificados possuem:
\begin{itemize}
    \item Primeira linha: tamanho original codificado
    \item Demais linhas: blocos de 31 bits em formato texto
    \item Separação por quebras de linha
\end{itemize}

\section{Vantagens e Limitações}

\subsection{Vantagens}
\begin{itemize}
    \item Correção automática de erros únicos
    \item Detecção de erros duplos
    \item Implementação eficiente em C
    \item Processamento por blocos para arquivos grandes
\end{itemize}

\subsection{Limitações}
\begin{itemize}
    \item Overhead de 19\% (5 bits extras para cada 26)
    \item Apenas erros únicos são corrigidos
    \item Erros múltiplos podem não ser detectados
    \item Limitação de tamanho de arquivo (26 bits)
\end{itemize}

\section{Conclusão}

A implementação apresentada demonstra uma aplicação prática e eficiente do código de Hamming para proteção de arquivos contra erros de transmissão ou armazenamento. O algoritmo balanceando eficiência computacional com capacidade de correção de erros, sendo adequado para aplicações onde erros únicos são predominantes.

A escolha do código (31,26) oferece um bom compromisso entre redundância e capacidade de correção, tornando-se uma solução viável para sistemas que necessitam de tolerância a falhas em comunicações digitais.

\end{document}